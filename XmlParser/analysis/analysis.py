from xml.etree.ElementTree import ElementTree
import pydot
import re
import copy
import sys
import collections
from networkx import nx

### Globals
graphs = {}
MethodMap = {}
IntentMethodStubs = collections.defaultdict(lambda: default_stub)
IntentClasses = ['Landroid/content/Intent;']
EntryPoints = [ "onResume", "onCreate", "onStart", "onRestart", "onPause",
"onStop", "onDestroy", "onCreate", "onStartCommand", "onDestroy", "onBind",
"onRebind", "onUnbind", "onTaskRemoved", "onTrimMemory", "onClick",
"onBackPressed", "onListItemClick", "onRestoreInstanceState", "onPostExecute",
"onReceive", "onOptionsItemSelected", "onFinish", "onSearchRequested",
"onItemLongClick", "onContectItemSelected", "onItemClick", "onComplete",
"onServiceConnected", "onUpdate", "onSyncCompleted", "onActionModeFinished",
"onActionModeStarted", "onAttachFragment", "onAttachedToWindow",
"onBackPressed", "onConfigurationChanged", "onContentChanged",
"onContextItemSelected", "onContextMenuClosed", "onCreateContextMenu",
"onCreateDescription", "onCreateOptionsMenu", "onCreatePanelMenu",
"onCreatePanelView", "onCreateThumbnail", "onCreateView", "onCreateView",
"onDetachedFromWindow", "onGenericMotionEvent", "onKeyDown", "onKeyLongPress",
"onKeyMultiple", "onKeyShortcut", "onKeyUp", "onLowMemory",
"onMenuItemSelected", "onMenuOpened", "onOptionsItemSelected",
"onOptionsMenuClosed", "onPanelClosed", "onPrepareOptionsMenu",
"onPreparePanel", "onRetainNonConfigurationInstance", "onSearchRequested",
"onTouchEvent", "onTrackballEvent", "onTrimMemory", "onUserInteraction",
"onWindowAttributesChanged", "onWindowFocusChanged",
"onWindowStartingActionMode"]
###

class BasicBlock(object):

    # Class Counter to Allow for Distinct Copies of Basic Blocks
    counter = 0

    def __init__(self, method_name, BB=None):
        self.method_name = method_name

        if BB:
            self.instructions = BB.instructions
        else:
            self.instructions = tuple()

        BasicBlock.counter += 1
        self.id = BasicBlock.counter

    def __hash__(self):
        return hash(hash(self.instructions) + hash(self.id))

    def __repr__(self):
        return '<%d>%s(ID=%d)' % (self.instructions[0].index(), str(self.instructions[-1]), self.id)

    def add_instruction(self, insn):
        self.instructions += (insn,)

    def entry_point_index(self):
        #Get the index of the 1st instruction of the BasicBlock
        return self.instructions[0].index()

    def tail_instruction(self):
        return self.instructions[-1]

    def __deepcopy__(self, memo):
        return BasicBlock(self.method_name, BB=self)

    def is_source(self):
        return len([i for i in self.instructions if i.is_source()]) > 0

    def is_sink(self):
        return len([i for i in self.instructions if i.is_sink()]) > 0

    def transfer(self, state):
        for i in self.instructions:
            i.transfer(state)

    def index(self):
        return self.instructions[0].index()

class Insn(object):
    def __init__(self, xml):
        self.xml = xml

    def __repr__(self):
        return self.opcode()

    def addr(self):
        return self.xml.get('baseAddr')

    def opcode(self):
        return self.xml.get('opCode')

    def index(self):
        return int(self.xml.get('index'), 16)

    def transfer(self, state):
        pass

    def throws_exception(self):
        return False

    def target_index(self):
        return None

    def is_source(self):
        return False

    def is_sink(self):
        return False
        
    def follows_sequential_instruction(self):
        return True

    def is_branch(self):
        return False

    def has_target(self):
        return self.target_index() != None

    def is_invoke(self):
        return False

    def is_return(self):
        return False

class Branch(Insn):
    def is_branch(self):
        return True

class Return(Branch):
    def is_return(self):
        return True

    def follows_sequential_instruction(self):
        return False

    def return_value_register(self):
        return self.xml.get('vA')

    def transfer(self, state):
        state.set_result(state[self.return_value_register()])
        state.pop()

class ReturnVoid(Return):
    def transfer(self, state):
        state.pop()

class Dummy_Return(Return):
    def opcode(self):
        return "Dummy Return"

    def index(self):
        return -1

class If(Branch):
    def target_index(self):
        return int(self.xml.get('vC'), 16)

class IfZero(If):
    def target_index(self):
        return int(self.xml.get('vB'), 16)

class Goto(Branch):
    def target_index(self):
        return int(self.xml.get('vA'), 16)

    def follows_sequential_instruction(self):
        return False

class Move(Insn):
    def dest(self):
        return self.xml.get('vA')

    def src(self):
        return self.xml.get('vB')

    def transfer(self, state):
        state[self.dest()] = state[self.src()]

    def __repr__(self):
        return '%s %s, %s' % (self.opcode(), self.dest(), self.src()) 

class MoveResult(Move):
    def transfer(self, state):
        state[self.dest()] = state.last_invoke_result

    def __repr__(self):
        return '%s %s' % (self.opcode(), self.dest())

def subclasses(parent_class, root):
    """Class names which are decendents of @param parent_class."""
    for class_el in root.findall('class'):
        if class_el.get('extends') == parent_class:
            child_class = class_el.get('name')
            yield child_class
            for grand_child_class in subclasses(child_class, root):
                yield grand_child_class

def intent_subclasses(root):
    """All classes which are subclasses of the Intent class"""
    return list(subclasses('Landroid/content/Intent;', root))

class NewInstance(Insn):
    def instance_type(self):
        return self.xml.get('vB')

    def dest(self):
        return self.xml.get('vA')

    def is_source(self):
        return self.instance_type() in IntentClasses

    def __repr__(self):
        return '%s %s %s' % (self.opcode(), self.dest(), self.instance_type())

    def transfer(self, state):
        if self.is_source():
            state[self.dest()] = Intent(self.addr())
        else:
            state[self.dest()] = 'Instance of ' + self.instance_type()

class Const(Move):
    def get_const(self):
        return int(self.src(), 16)

    def transfer(self, state):
        state[self.dest()] = self.get_const()

class ConstString(Move):
    def transfer(self, state):
        state[self.dest()] = str(self.src())

class Invoke(Branch):
    def __init__(self, xml):
        self.xml = xml
        self.invoke = True

    def __repr__(self):
        return self.signature()

    def throws_exception(self):
        return True

    def is_sink(self):
        return self.parse_invoked_method()[1] in ['sendBroadcast',
                'sendOrderedBroadcast', 'sendStickyBroadcast', 'startActivity',
                'startActivityForResult', 'startService', 'bindService']

    def parse_invoked_method(self):
        return parse_signature(self.xml.get('vC'))

    def signature(self):
        return "%s.%s(%s)" % self.parse_invoked_method()[:3]

    def is_invoke(self):
        return self.invoke

    def uninvoke(self):
        self.invoke = False

    def argc(self):
        return int(self.xml.get('vB'))

    def argv(self, state):
        return [state[self.xml.get(a)] for a in ['vD', 'vE', 'vF', 'vG', 'vA'][:self.argc()]]

    def collect_intent(self, state):
        if self.is_sink():
            intent = state[self.xml.get('vE')]
            state.add_sent_intent(intent)

    def force_cast_intent(self, state):
        """Cast first argument to an Intent, it not already"""
        r = self.xml.get('vD')
        if type(state[r]) != Intent:
            state[r] = Intent(self.addr())

    def transfer(self, state):
        if self.signature() not in MethodMap:
            if self.signature() in IntentMethodStubs:
                self.force_cast_intent(state)
            IntentMethodStubs[self.signature()](state, self.argv(state))
            return_type = parse_signature(self.xml.get('vC'))[-1]
            if return_type in IntentClasses:
                state.set_result(Intent(self.addr()))
        else:
            method_el = MethodMap[self.signature()]
            mapping = mapping_with_arguments(method_el, self.argv(state))
            state.push(mapping)
        self.collect_intent(state)

class Intent(object):
    def __init__(self, srcaddr):
        self.action = ''
        self.categories = []
        self.extras = {}
        self.classname = ''
        self.cls = ''
        self.uri = ''
        self.flags = 0
        self.srcaddr = srcaddr

    def copy(self, other):
        self.action = other.action
        self.categories = other.categories
        self.extras = other.extras
        self.classname = other.classname
        self.cls = other.cls
        self.uri = other.uri

    def set_classname(self, classname):
        self.classname = classname

    def set_class(self, cls):
        self.cls = cls

    def set_action(self, action):
        self.action = action

    def add_category(self, category):
        self.categories.append(category)

    def put_extra(self, key, val):
        self.extras[key] = val

    def is_explicit(self):
        return self.classname or self.cls

    def __repr__(self):
        s = 'Intent@%s(action=%s,categories=%s,extras=%s,classname=%s, class=%s, uri=%s, flags=%d)'
        return s % (self.srcaddr, self.action, self.categories, self.extras, self.classname, self.cls, self.uri, self.flags)

def parse_signature(signature):
    """http://source.android.com/tech/dalvik/dex-format.html"""
    rex = re.match(r'(.*)\.(.*)\((.*)\)(.*)', signature)
    c = rex.group(1)
    m = rex.group(2)
    ps = rex.group(3)
    r = rex.group(4)
    return c, m, ps, r

### Method stubs - aka library methods and the like ###
def stub(half_signature):
    def wrapped(f):
        for cls in IntentClasses:
            signature = cls + '.' + half_signature
            IntentMethodStubs[signature] = f
        return f
    return wrapped

@stub('<init>(Landroid/content/Context;Ljava/lang/Class;)')
@stub('setClass(Landroid/content/Context;Ljava/lang/Class;)')
def init_ctx_cls(state, args):
    intent, ctx, cls = args
    intent.set_class(cls)

@stub('<init>(Ljava/lang/String;Landroid/net/Uri;Landroid/content/Context;Ljava/lang/Class;)')
def init_action_uri_ctx_cls(state, args):
    intent, ctx, cls = args
    intent.set_class(cls)

@stub('<init>(Landroid/content/Intent;Landroid/content/Intent;)')
def init_intent(state, args):
    intent, other_intent = args
    intent.copy(other_intent)

@stub('<init>(Ljava/lang/String;)')
@stub('setAction(Ljava/lang/String;)')
def init_action(state, args):
    intent, action = args
    intent.set_action(action)

@stub('<init>(Ljava/lang/String;Landroid/net/Uri;)')
def init_action_uri(state, args):
    intent, action, uri = args
    intent.set_action(action)
    intent.uri = uri

@stub('setData(Landroid/net/Uri;)')
def set_data(state, args):
    intent, uri = args
    intent.uri = uri

@stub('setFlags(I)')
def set_flags(state, args):
    intent, flags = args
    intent.flags = flags

@stub('addFlags(I)')
def add_flags(state, args):
    intent, flags = args
    intent.flags |= flags

@stub('addCategory(Ljava/lang/String;)')
def add_category(state, args):
    intent, category = args
    intent.add_category(category)

@stub('putExtra(Ljava/lang/String;Landroid/os/Parcelable;)')
@stub('putExtra(Ljava/lang/String;Ljava/lang/String;)')
@stub('putExtra(Ljava/lang/String;D)')
@stub('putExtra(Ljava/lang/String;S)')
@stub('putExtra(Ljava/lang/String;I)')
@stub('putExtra(Ljava/lang/String;C)')
@stub('putExtra(Ljava/lang/String;J)')
@stub('putExtra(Ljava/lang/String;Z)')
@stub('putExtra(Ljava/lang/String;F)')
@stub('putExtra(Ljava/lang/String;Ljava/lang/CharSequence;)')
@stub('putExtra(Ljava/lang/String;Landroid/os/Bundle;)')
@stub('putExtra(Ljava/lang/String;Ljava/os/Serializable;)')
@stub('putExtra(Ljava/lang/String;[Landroid/os/Parcelable;)')
@stub('putExtra(Ljava/lang/String;[Ljava/lang/String;)')
@stub('putExtra(Ljava/lang/String;[D)')
@stub('putExtra(Ljava/lang/String;[S)')
@stub('putExtra(Ljava/lang/String;[I)')
@stub('putExtra(Ljava/lang/String;[C)')
@stub('putExtra(Ljava/lang/String;[J)')
@stub('putExtra(Ljava/lang/String;[Z)')
@stub('putExtra(Ljava/lang/String;[F)')
@stub('putExtra(Ljava/lang/String;[Ljava/lang/CharSequence;)')
@stub('putExtra(Ljava/lang/String;[Landroid/os/Bundle;)')
@stub('putExtra(Ljava/lang/String;[Ljava/os/Serializable;)')
def intent_put_extra(state, args):
    intent, key, val = args
    intent.put_extra(key, val)

@stub('setClassName(Ljava/lang/String;Ljava/lang/String;)')
@stub('setClassName(Ljava/lang/String;Landroid/content/Context;)')
def intent_set_classname(state, args):
    intent, pkgname, classname = args
    intent.set_classname(classname)

# The default stub
GlobalUnknownId = 0
def default_stub(state, args):
    global GlobalUnknownId
    state.set_result('%d?' % GlobalUnknownId)
    GlobalUnknownId += 1
#######################################################

def initial_state(entryMethod_xml):
    """Return the initial mapping of entryMethod_xml"""
    state = State()
    parameter_els = entryMethod_xml.findall('parameter')
    arguments = ['THIS']
    arguments += [p.get('name') for p in parameter_els]
    state.push(mapping_with_arguments(entryMethod_xml, arguments))
    return state

def mapping_with_arguments(method_xml, arguments):
    """A register mapping where the each argument is mapped to the appropriate
    parameter-register when the method is in its initial state."""
    mapping = {}
    num_registers = int(method_xml.find('code').get('registers'))
    start_index = num_registers - len(arguments)
    registers = [('v%d' % i) for i in range(start_index, num_registers)]
    for i, register in enumerate(registers):
        mapping[register] = arguments[i]
    return mapping

InstructionSet = {
    'if-eq': If,
    'if-ne': If,
    'if-lt': If,
    'if-ge': If,
    'if-gt': If,
    'if-le': If,
    'if-eqz': IfZero,
    'if-nez': IfZero,
    'if-ltz': IfZero,
    'if-gez': IfZero,
    'if-gtz': IfZero,
    'if-lez': IfZero,
    'goto': Goto,
    'goto/16': Goto,
    'invoke-virtual': Invoke,
    'invoke-super': Invoke,
    'invoke-direct': Invoke,
    'invoke-static': Invoke,
    'invoke-interface': Invoke,
    'const/4': Const,
    'const/16': Const,
    'const': Const,
    'const-string': ConstString,
    'const-class': ConstString,
    'const-string/jumbo': ConstString,
    'const-class/jumbo': ConstString,
    'const/high16': Const,
    'const-wide/16': Const,
    'const-wide/32': Const,
    'const-wide': Const,
    'const-wide/high16': Const,
    'return': Return,
    'return-void': ReturnVoid,
    'return-wide': Return,
    'return-object': Return,
    'move-result-object': MoveResult,
    'move-result': MoveResult,
    'move-result-wide': MoveResult,
    'move': Move,
    'move-object': Move,
    'iget-object': Move,
    'new-instance': NewInstance
}

class State(object):
    """Models a stack of register mappings. Mappings are pushed and popped off
    the stack via function invocations and returns."""
    def __init__(self):
        self.mappings = []
        self.last_invoke_result = None
        self.intents = []

    def add_sent_intent(self, intent):
        self.intents.append(intent)

    def __getitem__(self, key):
        """Return value mapped by register @key of current mapping."""
        if key not in self.mappings[-1]:
            return 'wtf ???'
        return self.mappings[-1][key]

    def __setitem__(self, key, value):
        """Map register @key to @value in current mapping."""
        self.mappings[-1][key] = value

    def __repr__(self):
        return '|||'.join(map(str, self.mappings))

    def set_result(self, value):
        self.last_invoke_result = value

    def push(self, state):
        """Save current register mapping to stack and set current mapping to
        empty."""
        self.mappings.append(state)

    def pop(self):
        """Set current register mapping to last mapping."""
        return self.mappings.pop()

def insn_from_xml(insn_el):
    opcode = insn_el.get('opCode')
    insn = InstructionSet.setdefault(opcode, Insn)(insn_el)
    return insn

def insns_from_xml(method_el):
    bytecodes_el = method_el.find('code').find('bytecodes')
    if bytecodes_el is None:
        return []
    insn_els = bytecodes_el.findall('insn')
    insns = []
    for insn_el in insn_els:
        opcode = insn_el.get('opCode')
        insn = insn_from_xml(insn_el)
        insns.append(insn)
    return insns

def exception_handlers(method_el):
    """Returns a dictionary containing key value pairs for each try block.

    key = (start, end) the start and end instruction indices of the try block
    value = [index1, index2, ...] a list of catch indices

    Note: It would be really hard to figure out where an instruction would be
    caught if there are multiple catches for a try block, so we follow all of
    them."""
    code_el = method_el.find('code')
    catches_el = code_el.find('catches')
    if catches_el is None:
        return {}
    handlers = {}
    for try_el in catches_el.findall('try'):
        start = int(try_el.get('start'), 16)
        end = int(try_el.get('end'), 16)
        handlers[(start, end)] = []
        for handler_el in try_el.findall('handler'):
            index = int(handler_el.get('address'), 16)
            handlers[(start, end)].append(index)
    return handlers

def leaders(method_el):
    insns = insns_from_xml(method_el)

    # 0. The first instruction is the entry point to the method.
    ldrs = set([insns[0]])

    # 1. Get branch targets, and instructions following branches.
    for i, insn in enumerate(insns):
        if insn.is_branch():
            ldrs.add(insn.target_index())
            if (i+1) in range(len(insns)):
                ldrs.add(insns[i+1].index())

    handlers = exception_handlers(method_el)
    # 2. Get all indices of exception handlers, because control will jump there
    # when exceptions are thrown.
    for handler_indices in handlers.values():
        ldrs |= set(handler_indices)

    # 3. For every instruction which might jump to an exception handler, the
    # following instruction starts a new basic block.
    for start, end in handlers:
        for i, insn in enumerate(insns):
            if insn.throws_exception() and insn.index() in range(start, end+1) and (i+1) in range(len(insns)):
                ldrs.add(insns[i+1].index())

    return ldrs

def basic_blocks(method_el):
    insns = insns_from_xml(method_el)
    ldrs = leaders(method_el)
    bbs = []
    bb = BasicBlock(method_el.get('name'))
    for insn in insns:
        if insn.index() in ldrs and bb.instructions:
            bbs.append(bb)
            bb = BasicBlock(method_el.get('name'))
        bb.add_instruction(insn)
    if bb: bbs.append(bb)
    return bbs

def graph_from_xml(method_el):
    insns = insns_from_xml(method_el)
    bbs = basic_blocks(method_el)
    graph = nx.DiGraph()
    bb_entry_points = {}
    for bb in bbs:
        bb_entry_points[bb.entry_point_index()] = bb

    # 0. Connect sequential basic blocks
    for i, bb in enumerate(bbs):
        tail = bb.tail_instruction()
        if tail.follows_sequential_instruction():
            if (i+1) in range(len(bbs)):
                graph.add_edge(bb, bbs[i+1])

    # 1. Connect branches
    for bb in bbs:
        tail = bb.tail_instruction()
        if tail.has_target():
            dest = bb_entry_points[tail.target_index()]
            graph.add_edge(bb, dest)

    # 2. Connect blocks within try blocks to handler entry points
    handlers = exception_handlers(method_el)
    for start, end in handlers:
        for bb in bbs:
            if bb.index() in range(start, end+1):
                for index in handlers[(start, end)]:
                    graph.add_edge(bb, bb_entry_points[index])
    return graph

def visualize(graph):
    dot_graph = nx.to_pydot(graph)
    dot_graph.write_png('example.png')

def method_signature_from_xml(class_el, method_el):
    class_name = class_el.get('name')
    method_name = method_el.get('name')
    parameters = []
    parameter_els = method_el.findall('parameter')
    for param_el in parameter_els:
        parameters.append(param_el.get('type'))
    return "%s.%s(%s)" % (class_name, method_name, "".join(parameters))

def copy_graph(G):
    new_graph = nx.DiGraph()
    node_mapping = {}

    for node in G.nodes():
        new_node = copy.deepcopy(node)
        node_mapping[node] = new_node
        new_graph.add_node(new_node)

    new_edges = []

    for (n1, n2) in G.edges():
        new_edges.append((node_mapping[n1], node_mapping[n2]))

    new_graph.add_edges_from(new_edges)

    return new_graph

def find_all_paths(graph, start, end, path=[], closed=set()):
    """Time Complexity O(n!)"""
    path = path + [start]
    closed = closed | set([start]) # O(1) lookup time
    if start == end:
        return [path]
    paths = []
    for node in graph.neighbors(start):
        if node not in closed:
            newpaths = find_all_paths(graph, node, end, path, closed)
            for newpath in newpaths:
                paths.append(newpath)
    return paths

def expand_method(method):
    for caller_bb in method.nodes():
        insn = caller_bb.tail_instruction()
        if insn.is_invoke():
            # Make sure this node is not expanded again
            insn.uninvoke()

            if insn.signature() not in graphs:
                pass
                # Means it's calling a super class
                # Or Landroid, Ljava, etc...
            else:
                # If the caller_bb is invoke, the return block is the one it is linked to
#===============================================================
                #HACK. Calls are not guaranteed to be follwed by another bb?
                #Create a fake return_bb
                if method.successors(caller_bb):
                    return_bb = method.successors(caller_bb)[0]
                    # Destroy the Edge between the caller_bb and the return_bb
                    method.remove_edge(caller_bb, return_bb)
                else:
                    return_bb = BasicBlock(caller_bb.method_name)
                    return_bb.add_instruction(Dummy_Return(None))
                    method.add_node(return_bb)

                # Create a copy of the graph of the function we are calling
                method_graph = copy_graph(graphs[insn.signature()])
                method = nx.union(method, method_graph)

                #Link caller to entry point of method graph
                for callee_bb in method_graph.nodes():
                    if callee_bb.index() == 0:
                        method.add_edge(caller_bb, callee_bb)

                #Link return blocks to the return_bb in the caller
                for callee_bb in method_graph.nodes():
                    # If a basic block ends with a return, link it back to the
                    # return_bb in the caller graph
                    if callee_bb.tail_instruction().is_return():
                        method.add_edge(callee_bb, return_bb)
    return method

def find_all_methods(root):
    for class_el in root.findall('class'):
        for method_el in class_el.findall('method'):
            code_el = method_el.find('code')
            if code_el is None or code_el.find('bytecodes') is None:
                continue
            graph = graph_from_xml(method_el)
            signature = method_signature_from_xml(class_el, method_el)
            graphs[signature] = graph
            MethodMap[signature] = method_el

def find_all_entry_points():
    """Return all method signatures whose methods represent entry points into
    the app."""
    signatures = []
    for signature in MethodMap:
        # Find All Activity Entry Points
        method_el = MethodMap[signature]
        if method_el.get('name') in EntryPoints:
            signatures.append(signature)
    return signatures

def expand_to_fixed_point(method, count):
    original_count = method.number_of_nodes()
    for i in xrange(0, count):
        method = expand_method(method)
        new_count = method.number_of_nodes()
        if original_count == new_count:
            break
        original_count = new_count
    return method

def get_entry_nodes(method):
    return [n for n in method.nodes() if n.index() == 0]

def find_all_intent_paths(entry_nodes, method):
    entry_paths = []
    exit_paths = []
    combined_paths = []
    source_nodes = [node for node in method.nodes() if node.is_source()]
    sink_nodes = [node for node in method.nodes() if node.is_sink()]
    for entry in entry_nodes:
        for source in source_nodes:
            entry_paths += find_all_paths(method, entry, source)
    for source in source_nodes:
        for sink in sink_nodes:
            exit_paths += find_all_paths(method, source, sink)
    for entry_path in entry_paths:
        for exit_path in exit_paths:
            if entry_path[-1] is exit_path[0]:
                combined_paths.append(entry_path + exit_path)
    return combined_paths

def colorize(s, color):
    codes = {'red': 31, 'yellow': 33, 'green': 32}
    return '\033[0;%dm' % codes[color] + s + '\033[0;m'

def get_parsed_tree(xml_dump_path):
    tree = ElementTree()
    tree.parse(xml_dump_path)
    return tree

def find_intents(tree):
    global IntentClasses
    find_all_methods(tree)
    IntentClasses += intent_subclasses(tree)
    entry_points = find_all_entry_points()
    intents = {}
    for signature in entry_points:
        entryPoint_method = graphs[signature]
        entry_nodes = get_entry_nodes(entryPoint_method) # Do this BEFORE expansion
        entryPoint_method = expand_to_fixed_point(entryPoint_method, 10)
        entryPoint_xml = MethodMap[signature]
        combined_paths = find_all_intent_paths(entry_nodes, entryPoint_method)
        for path in combined_paths:
            state = initial_state(entryPoint_xml)
            for node in path:
                node.transfer(state)
            for intent in state.intents:
                # Hack, since I can't figure out how sets work for user classes
                intents[str(intent)] = intent
    return intents.values()

def analyze(intents):
    explicit_intents = [i for i in intents if i.is_explicit()]
    implicit_intents = [i for i in intents if not i.is_explicit()]
    for intent in explicit_intents:
        print colorize(str(intent), 'green')
    for intent in implicit_intents:
        print colorize(str(intent), 'red')

def visualize_method(root, class_name, method_name):
    for class_el in root.findall('class'):
        if class_el.get('name') != class_name:
            continue
        for method_el in class_el.findall('method'):
            if method_el.get('name') != method_name:
                continue
            visualize(graph_from_xml(method_el))
            break

def usage():
    print 'usage: %s <path to XML dump>' % sys.argv[0]
    exit(-1)

def main():
    if len(sys.argv) != 2:
        usage()
    dump_path = sys.argv[1]
    root = get_parsed_tree(dump_path)
    intents = find_intents(root)
    analyze(intents)

if __name__ == '__main__':
    main()
