from xml.etree.ElementTree import ElementTree
import pydot
import re

class BasicBlock(object):
    def __init__(self, xml):
        self.instructions = []

class Insn(object):
    def __init__(self, xml):
        self.xml = xml

    def __repr__(self):
        return str(self.index()) + ':' + self.opcode()

    def opcode(self):
        return self.xml.get('opCode')

    def index(self):
        return int(self.xml.get('index'), 16)

    def transfer(self, state):
        pass

    def target_index(self):
        return None

    def is_source(self):
        return False

    def is_sink(self):
        return False
        
    def follows_sequential_instruction(self):
        return True

    def ends_block(self):
        return False

    def has_target(self):
        return self.target_index() != None

class Branch(Insn):
    def ends_block(self):
        return True

class Return(Branch):
    def is_return(self):
        return True

    def follows_sequential_instruction(self):
        return False

class If(Branch):
    def target_index(self):
        return int(self.xml.get('vC'), 16)

class IfZero(If):
    def target_index(self):
        return int(self.xml.get('vB'), 16)

class Goto(Branch):
    def target_index(self):
        return int(self.xml.get('vA'), 16)

    def follows_sequential_instruction(self):
        return False

class Move(Insn):
    def dest(self):
        return self.xml.get('vA')

    def src(self):
        return self.xml.get('vB')

    def transfer(self, state):
        state[self.dest()] = state[self.src()]

class MoveResultObject(Move):
    def transfer(self, state):
        state[self.dest()] = 1337 # FIXME

class Const(Move):
    def transfer(self, state):
        state[self.dest()] = int(self.src(), 16)

class ConstString(Move):
    def transfer(self, state):
        state[self.dest()] = self.src()

def get_class_and_method(signature):
    pattern = r'(?P<class>\w+(/\w+)*;)\.(?P<method>[^\(]+)\(.*\)'
    res = re.search(pattern, signature)
    return res.group('class'), res.group('method')

class Invoke(Branch):
    def __init__(self, xml):
        self.xml = xml

    def get_class_name(self):
        return get_class_and_method(self.xml.get('vC'))[0]

    def get_method_name(self):
        return get_class_and_method(self.xml.get('vC'))[1]

    def is_source(self):
        class_name = self.get_class_name()
        method_name = self.get_method_name()
        INTENT_CLASS = 'Landroid/content/Intent;'
        return class_name == INTENT_CLASS and method_name == '<init>'

    def is_sink(self):
        return self.get_method_name() in ['sendBroadcast',
                'sendOrderedBroadcast', 'sendStickyBroadcast', 'startActivity',
                'startService', 'bindService']

classes = {
    'if-eq': If,
    'if-ne': If,
    'if-lt': If,
    'if-ge': If,
    'if-gt': If,
    'if-le': If,
    'if-eqz': IfZero,
    'if-nez': IfZero,
    'if-ltz': IfZero,
    'if-gez': IfZero,
    'if-gtz': IfZero,
    'if-lez': IfZero,
    'goto': Goto,
    'goto/16': Goto,
    'invoke-virtual': Invoke,
    'invoke-super': Invoke,
    'invoke-direct': Invoke,
    'invoke-static': Invoke,
    'invoke-interface': Invoke,
    'const/4': Const,
    'const/16': Const,
    'const': Const,
    'const-string': ConstString,
    'const-class': ConstString,
    'const-string/jumbo': ConstString,
    'const-class/jumbo': ConstString,
    'const/high16': Const,
    'const-wide/16': Const,
    'const-wide/32': Const,
    'const-wide': Const,
    'const-wide/high16': Const,
    'return': Return,
    'return-void': Return,
    'return-wide': Return,
    'return-object': Return,
    'move-result-object': MoveResultObject,
    'move': Move
}

def insn_from_xml(insn_el):
    opcode = insn_el.get('opCode')
    insn = classes.setdefault(opcode, Insn)(insn_el)
    return insn

def insns_from_xml(method_el):
    bytecodes_el = method_el.find('code').find('bytecodes')
    if bytecodes_el is None:
        return []
    insn_els = bytecodes_el.findall('insn')
    insns = []
    for insn_el in insn_els:
        opcode = insn_el.get('opCode')
        insn = insn_from_xml(insn_el)
        insns.append(insn)
    return insns

def leaders(insns):
    indices = set([insns[0].index()])
    for i, insn in enumerate(insns):
        if insn.ends_block():
            indices.add(insn.target_index())
            if (i+1) in range(len(insns)):
                indices.add(insns[i+1].index())
    return indices

def basic_blocks(insns):
    ldrs = leaders(insns)
    bbs = []
    bb = []
    for insn in insns:
        if insn.index() in ldrs and bb:
            bbs.append(tuple(bb))
            bb = []
        bb.append(insn)
    if bb: bbs.append(tuple(bb))
    return bbs

class Graph(object):
    def __init__(self, nodes):
        self.nodes = {}
        for node in nodes:
            self.nodes[node] = []
        self.root = nodes[0]

    def __iter__(self):
        s = [self.root]
        visited = set()
        while s:
            node = s.pop()
            yield node
            visited.add(node)
            for n in self.neighbors(node):
                if n not in visited:
                    s.append(n)

    def add_edge(self, src, dest):
        self.nodes[src].append(dest)

    def neighbors(self, node):
        return self.nodes[node]

def graph_from_xml(method_el):
    insns = insns_from_xml(method_el)
    bbs = basic_blocks(insns)
    graph = Graph(bbs)
    bb_entry_points = {}
    for bb in bbs:
        bb_entry_points[bb[0].index()] = bb
    for i, bb in enumerate(bbs):
        tail = bb[-1]
        if tail.follows_sequential_instruction():
            if (i+1) in range(len(bbs)):
                graph.add_edge(bb, bbs[i+1])
        if tail.has_target():
            dest = bb_entry_points[tail.target_index()]
            graph.add_edge(bb, dest)
    return graph

def node_sinks(node):
    return [insn for insn in node if insn.is_sink()]

def node_sources(node):
    return [insn for insn in node if insn.is_source()]

def graph_sources(graph):
    for node in graph:
        if node_sources(node):
            yield node

def graph_sinks(graph):
    for node in graph:
        if node_sinks(node):
            yield node

def all_simple_paths(graph, start, end, path=[]):
    path = path + [start]
    if start == end:
        return [path]
    paths = []
    for node in graph.neighbors(start):
        if node not in path:
            newpaths = all_simple_paths(graph, node, end, path)
            for newpath in newpaths:
                paths.append(newpath)
    return paths

def label(node):
    return '%d [%s]' % (node[0].index(), node[-1].opcode())

def visualize(graph):
    dot_graph = pydot.Dot(graph_type='digraph')
    for node in graph:
        for n in graph.neighbors(node):
            edge = pydot.Edge(label(node), label(n))
            dot_graph.add_edge(edge)
    dot_graph.write_png('example.png')

graphs = []
tree = ElementTree()
tree.parse('method.xml')
#for class_el in tree.findall('class'):
#    for method_el in class_el.findall('method'):
#code_el = method_el.find('code')
#if code_el is None or code_el.find('bytecodes') is None:
#   continue
method_el = tree.getroot()
graph = graph_from_xml(method_el)
graphs.append(graph)

print len(graphs)
visualize(graphs[0])
