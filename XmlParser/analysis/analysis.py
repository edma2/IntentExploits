from xml.etree.ElementTree import ElementTree
import pydot
import re
import copy
from networkx import nx

# Global Counter to Allow for Distinct Copies of Basic Blocks
global_counter = 0

class BasicBlock(object):
    def __init__(self, method_name, BB=None):
        global global_counter

        self.method_name = method_name

        if BB:
            self.instructions = BB.instructions
        else:
            self.instructions = tuple()

        global_counter += 1
        self.id = global_counter

    def __hash__(self):
        return hash(hash(self.instructions) + hash(self.id))

    def __repr__(self):
        return '<%d>%s' % (self.instructions[0].index(), str(self.instructions[-1]))

    def add_instruction(self, insn):
        self.instructions += (insn,)

    def entry_point_index(self):
        #Get the index of the 1st instruction of the BasicBlock
        return self.instructions[0].index()

    def tail_instruction(self):
        return self.instructions[-1]

    def __deepcopy__(self, memo):
        return BasicBlock(self.method_name, BB=self)

    def is_source(self):
        return len([i for i in self.instructions if i.is_source()]) > 0

    def is_sink(self):
        return len([i for i in self.instructions if i.is_sink()]) > 0

    def transfer(self, state):
        for i in self.instructions:
            i.transfer(state)

    def index(self):
        return self.instructions[0].index()

class Insn(object):
    def __init__(self, xml):
        self.xml = xml

    def __repr__(self):
        return self.opcode()

    def opcode(self):
        return self.xml.get('opCode')

    def index(self):
        return int(self.xml.get('index'), 16)

    def transfer(self, state):
        pass

    def target_index(self):
        return None

    def is_source(self):
        return False

    def is_sink(self):
        return False
        
    def follows_sequential_instruction(self):
        return True

    def ends_block(self):
        return False

    def has_target(self):
        return self.target_index() != None

    def is_invoke(self):
        return False

    def is_return(self):
        return False

class Branch(Insn):
    def ends_block(self):
        return True

class Return(Branch):
    def is_return(self):
        return True

    def follows_sequential_instruction(self):
        return False

class Dummy_Return(Return):
    def opcode(self):
        return "Dummy Return"

    def index(self):
        return -1

class If(Branch):
    def target_index(self):
        return int(self.xml.get('vC'), 16)

class IfZero(If):
    def target_index(self):
        return int(self.xml.get('vB'), 16)

class Goto(Branch):
    def target_index(self):
        return int(self.xml.get('vA'), 16)

    def follows_sequential_instruction(self):
        return False

class Move(Insn):
    def dest(self):
        return self.xml.get('vA')

    def src(self):
        return self.xml.get('vB')

    def transfer(self, state):
        state[self.dest()] = state[self.src()]

class MoveResultObject(Move):
    def transfer(self, state):
        state[self.dest()] = 1337 # FIXME

class Const(Move):
    def transfer(self, state):
        state[self.dest()] = int(self.src(), 16)

class ConstString(Move):
    def transfer(self, state):
        state[self.dest()] = str(self.src())

class Invoke(Branch):
    def __init__(self, xml):
        self.xml = xml
        self.invoke = True

    def __repr__(self):
        return self.signature()

    def is_source(self):
        cname, mname, params = self.parse_invoked_method()
        INTENT_CLASS = 'Landroid/content/Intent;'
        return cname == INTENT_CLASS and mname == '<init>'

    def is_sink(self):
        return self.parse_invoked_method()[1] in ['sendBroadcast',
                'sendOrderedBroadcast', 'sendStickyBroadcast', 'startActivity',
                'startService', 'bindService']

    def parse_invoked_method(self):
        signature = self.xml.get('vC')
        rex = re.match(r'(.*)\.(.*)\(((.*))\)', signature)
        cname = rex.group(1)
        mname = rex.group(2)
        params = rex.group(3)
        return cname, mname, params

    def signature(self):
        return "%s.%s(%s)" % self.parse_invoked_method()

    def is_invoke(self):
        return self.invoke

    def uninvoke(self):
        self.invoke = False

    def transfer(self, state):
        mappings = {}
        if self.signature() not in MethodMap:
            # FIXME method stub
            return
        method_el = MethodMap[self.signature()]
        targets = argument_registers(method_el)
        for i, target in enumerate(targets):
            mappings[target] = state[self.xml.get(['vD', 'vE', 'vF', 'vG', 'vA'][i])]
        state.push(mappings)

def argument_registers(method_xml):
    """Return a list of registers which receive arguments when method is
    called."""
    num_params = len(method_xml.findall('parameter'))
    num_registers = int(method_xml.find('code').get('registers'))
    # k parameters land in last k registers
    max_register = num_registers-1
    result = []
    while num_params > 0:
        result.append('v%d' % max_register)
        num_params -= 1
        max_register -= 1
    return result

classes = {
    'if-eq': If,
    'if-ne': If,
    'if-lt': If,
    'if-ge': If,
    'if-gt': If,
    'if-le': If,
    'if-eqz': IfZero,
    'if-nez': IfZero,
    'if-ltz': IfZero,
    'if-gez': IfZero,
    'if-gtz': IfZero,
    'if-lez': IfZero,
    'goto': Goto,
    'goto/16': Goto,
    'invoke-virtual': Invoke,
    'invoke-super': Invoke,
    'invoke-direct': Invoke,
    'invoke-static': Invoke,
    'invoke-interface': Invoke,
    'const/4': Const,
    'const/16': Const,
    'const': Const,
    'const-string': ConstString,
    'const-class': ConstString,
    'const-string/jumbo': ConstString,
    'const-class/jumbo': ConstString,
    'const/high16': Const,
    'const-wide/16': Const,
    'const-wide/32': Const,
    'const-wide': Const,
    'const-wide/high16': Const,
    'return': Return,
    'return-void': Return,
    'return-wide': Return,
    'return-object': Return,
    'move-result-object': MoveResultObject,
    'move': Move
}

class State(object):
    """Models a stack of register mappings. Mappings are pushed and popped off
    the stack via function invocations and returns."""
    def __init__(self):
        self.mappings = []

    def __getitem__(self, key):
        """Return value mapped by register @key of current mapping."""
        return self.mappings[-1][key]

    def __setitem__(self, key, value):
        """Map register @key to @value in current mapping."""
        self.mappings[-1][key] = value

    def __repr__(self):
        return '|||'.join(map(str, self.mappings))

    def push(self, state):
        """Save current register mapping to stack and set current mapping to
        empty."""
        self.mappings.append(state)

    def pop(self):
        """Set current register mapping to last mapping."""
        return self.mappings.pop()

def insn_from_xml(insn_el):
    opcode = insn_el.get('opCode')
    insn = classes.setdefault(opcode, Insn)(insn_el)
    return insn

def insns_from_xml(method_el):
    bytecodes_el = method_el.find('code').find('bytecodes')
    if bytecodes_el is None:
        return []
    insn_els = bytecodes_el.findall('insn')
    insns = []
    for insn_el in insn_els:
        opcode = insn_el.get('opCode')
        insn = insn_from_xml(insn_el)
        insns.append(insn)
    return insns

def leaders(insns):
    indices = set([insns[0].index()])
    for i, insn in enumerate(insns):
        if insn.ends_block():
            indices.add(insn.target_index())
            if (i+1) in range(len(insns)):
                indices.add(insns[i+1].index())
    return indices

def basic_blocks(insns, method_name):
    ldrs = leaders(insns)
    bbs = []
    bb = BasicBlock(method_name)
    for insn in insns:
        if insn.index() in ldrs and bb.instructions:
            bbs.append(bb)
            bb = BasicBlock(method_name)
        bb.add_instruction(insn)
    if bb: bbs.append(bb)
    return bbs

def graph_from_xml(method_el, method_name):
    insns = insns_from_xml(method_el)
    bbs = basic_blocks(insns, method_name)
    graph = nx.DiGraph()
    bb_entry_points = {}
    for bb in bbs:
        bb_entry_points[bb.entry_point_index()] = bb
    for i, bb in enumerate(bbs):
        tail = bb.tail_instruction()
        if tail.follows_sequential_instruction():
            if (i+1) in range(len(bbs)):
                graph.add_edge(bb, bbs[i+1])
        if tail.has_target():
            dest = bb_entry_points[tail.target_index()]
            graph.add_edge(bb, dest)
    return graph

def visualize(graph):
    dot_graph = nx.to_pydot(graph)
    dot_graph.write_png('example.png')

def method_signature_from_xml(class_el, method_el):
    class_name = class_el.get('name')
    method_name = method_el.get('name')
    parameters = []
    parameter_els = method_el.findall('parameter')
    for param_el in parameter_els:
        parameters.append(param_el.get('type'))
    return "%s.%s(%s)" % (class_name, method_name, "".join(parameters))

def copy_graph(G):
    new_graph = nx.DiGraph()
    node_mapping = {}

    for node in G.nodes():
        new_node = copy.deepcopy(node)
        node_mapping[node] = new_node
        new_graph.add_node(new_node)

    new_edges = []

    for (n1, n2) in G.edges():
        new_edges.append((node_mapping[n1], node_mapping[n2]))

    new_graph.add_edges_from(new_edges)

    return new_graph

graphs = {}
MethodMap = {}
activity_entry_points = []
tree = ElementTree()
tree.parse('dump.xml')
for class_el in tree.findall('class'):
    for method_el in class_el.findall('method'):
        code_el = method_el.find('code')
        if code_el is None or code_el.find('bytecodes') is None:
            continue
        graph = graph_from_xml(method_el, method_el.get('name'))
        signature = method_signature_from_xml(class_el, method_el)
        graphs[signature] = graph
        MethodMap[signature] = method_el

        # Find All Activity Entry Points
        entry_points = ["onResume", "onCreate", "onStart", "onRestart",
                "onPause", "onStop", "onDestroy"]
        if method_el.get('name') in entry_points:
            print "Entry Point:", class_el.get('name')
            activity_entry_points.append((class_el.get('name'), graph))

def find_all_paths(graph, start, end, path=[]):
        path = path + [start]
        if start == end:
            return [path]
#        if not graph.has_key(start):
#            return []
        paths = []
        for node in graph.neighbors(start):
            if node not in path:
                newpaths = find_all_paths(graph, node, end, path)
                for newpath in newpaths:
                    paths.append(newpath)
        return paths

def expand_method(method):
    for caller_bb in method.nodes():
        insn = caller_bb.tail_instruction()
        if insn.is_invoke():
            # Make sure this node is not expanded again
            insn.uninvoke()

            if insn.signature() not in graphs:
                pass
                # Means it's calling a super class
                # Or Landroid, Ljava, etc...
            else:
                # If the caller_bb is invoke, the return block is the one it is linked to
#===============================================================
                #HACK. Calls are not guaranteed to be follwed by another bb?
                #Create a fake return_bb
                if method.successors(caller_bb):
                    return_bb = method.successors(caller_bb)[0]
                    # Destroy the Edge between the caller_bb and the return_bb
                    method.remove_edge(caller_bb, return_bb)
                else:
                    return_bb = BasicBlock(caller_bb.method_name)
                    return_bb.add_instruction(Dummy_Return(None))
                    method.add_node(return_bb)

                # Create a copy of the graph of the function we are calling
                method_graph = copy_graph(graphs[insn.signature()])
                method = nx.union(method, method_graph)

                #Link caller to entry point of method graph
                for callee_bb in method_graph.nodes():
                    if method_graph.in_degree(callee_bb) == 0:
                        method.add_edge(caller_bb, callee_bb)
                        break

                #Link return blocks to the return_bb in the caller
                for callee_bb in method_graph.nodes():
                    # If a basic block ends with a return, link it back to the
                    # return_bb in the caller graph
                    if callee_bb.tail_instruction().is_return():
                        method.add_edge(callee_bb, return_bb)
    return method

class_name, onCreate_method = activity_entry_points[20]
original_count = onCreate_method.number_of_nodes()
for i in xrange(0,10):
    onCreate_method = expand_method(onCreate_method)
    new_count = onCreate_method.number_of_nodes()
    if original_count == new_count:
        print "Finished after %i iterations" % i
        break
    original_count = new_count

entry_nodes = []
entry_paths = []
exit_paths = []
combined_paths = []

#List of all paths between source nodes and sink nodes
for node in onCreate_method.nodes():
    if node.index() == 0:
        entry_nodes += [node]
        break

source_nodes = [node for node in onCreate_method.nodes() if node.is_source()]
sink_nodes = [node for node in onCreate_method.nodes() if node.is_sink()]

print source_nodes, sink_nodes

for entry in entry_nodes:
    for source in source_nodes:
        entry_paths += find_all_paths(onCreate_method, entry, source)

for source in source_nodes:
    for sink in sink_nodes:
        exit_paths += find_all_paths(onCreate_method, source, sink)

for entry_path in entry_paths:
    for exit_path in exit_paths:
        if entry_path[-1] is exit_path[0]:
            combined_paths.append(entry_path + exit_path)

for path in combined_paths:
    state = State()
    state.push({}) # initially, empty mapping
    for node in path:
        node.transfer(state)
    print state

#Temporary - To See what a combination will look like
print "Visualizing:", class_name
visualize(onCreate_method)
