import xml.etree.ElementTree as etree
import visualize
import time
import re

# Maps method signatures to Methods
Methods = {}
methods_with_intents = []

def method_call(opcode):
    return opcode in ['invoke-virtual','invoke-super', 'invoke-direct', 'invoke-static', 'invoke-interface']

class Method(object):
    def __init__(self, classname, element, method_map=Methods):
        self.classname = classname
        self.element = element
        self.method_map = method_map
        self.method_map[self.signature()] = self

    def signature(self):
        name = self.element.get('name')
        param_types = self.param_types()
        return_type = self.element.get('return')
        return '%s.%s(%s)%s' % (self.classname, name, ','.join(param_types), return_type)

    def callsites(self):
        insns = self.element.findall('code/bytecodes/insn')
        for insn in insns:
            opcode = insn.get('opCode')
            if method_call(opcode):
                yield insn

    def callees(self):
        for callsite in self.callsites():
            callee_signature = callsite.get('vC')
            if callee_signature in self.method_map:
                yield self.method_map[callee_signature]

    def creates_intent(self):
        for callsite in self.callsites():
            callee_signature = callsite.get('vC')
            if re.match(r'Landroid/content/Intent;.<init>', callee_signature):
                return True
        return False

    def param_types(self):
        return [p.get('type') for p in self.element.findall('parameter')]

    def has_intent_param(self):
        return 'Landroid/content/Intent;' in self.param_types()

world = visualize.StreamingInterface()
time.sleep(2)

# Find all Methods
classes = etree.parse('dump.xml').findall('class')
for cls in classes:
    classname = cls.get('name')
    methods = cls.findall('method');
    for method in methods:
        method = Method(classname, method)
        #world.send_entity_up(method.signature(), 'circle')

for signature in Methods:
    method = Methods[signature]
    if method.has_intent_param():
        methods_with_intents.append(method)
        print len(methods_with_intents), method.signature()

# Print caller/callees relationships
for signature in Methods:
    method = Methods[signature]
    for callee in method.callees():
        pass
        #print method.signature(), '->', callee.signature()
        #world.send_link_up(method.signature(), 0, callee.signature(), 0)
