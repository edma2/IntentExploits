import xml.etree.ElementTree as etree
import visualize
import time

# Maps method signatures to Methods
Methods = {}

def method_call(opcode):
    return opcode in ['invoke-virtual','invoke-super', 'invoke-direct', 'invoke-static', 'invoke-interface']

class Method(object):
    def __init__(self, classname, element):
        self.classname = classname
        self.element = element

    def signature(self):
        name = self.element.get('name')
        param_types = [p.get('type') for p in self.element.findall('parameter')]
        return_type = self.element.get('return')
        return '%s.%s(%s)%s' % (self.classname, name, ','.join(param_types), return_type)

    def callees(self):
        insns = self.element.findall('code/bytecodes/insn')
        for insn in insns:
            opcode = insn.get('opCode')
            if not method_call(opcode):
                continue

            callee_signature = insn.get('vC')

            # If it's not defined anywhere, it must be a part of some external
            # library. Ignore these for now.
            if callee_signature not in Methods:
                continue

            yield Methods[callee_signature]

world = visualize.StreamingInterface()
time.sleep(2)

# Find all Methods
classes = etree.parse('dump.xml').findall('class')
for cls in classes:
    classname = cls.get('name')
    methods = cls.findall('method');
    for method in methods:
        method = Method(classname, method)
        Methods[method.signature()] = method
        world.send_entity_up(method.signature(), 'circle')

# Print caller/callees relationships
for signature in Methods:
    method = Methods[signature]
    for callee in method.callees():
        world.send_link_up(method.signature(), 0, callee.signature(), 0)
