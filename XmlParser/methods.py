import xml.etree.ElementTree as etree
import visualize
import time
import re

from pygraph.classes.digraph import digraph
from pygraph.algorithms.searching import breadth_first_search

# Graph
gr = digraph()

# Maps method signatures to Methods
Methods = {}
main_methods = []
methods_create_intents = []
methods_param_intents = []

def method_call(opcode):
    return opcode in ['invoke-virtual','invoke-super', 'invoke-direct', 'invoke-static', 'invoke-interface']

class Method(object):
    def __init__(self, classname, element, method_map=Methods):
        self.classname = classname
        self.element = element
        self.method_map = method_map
        self.method_map[self.signature()] = self

    def signature(self):
        name = self.element.get('name')
        param_types = self.param_types()
        return_type = self.element.get('return')
        return '%s.%s(%s)%s' % (self.classname, name, ','.join(param_types), return_type)

    def callsites(self):
        insns = self.element.findall('code/bytecodes/insn')
        for insn in insns:
            opcode = insn.get('opCode')
            if method_call(opcode):
                yield insn

    def callees(self):
        for callsite in self.callsites():
            callee_signature = callsite.get('vC')
            if callee_signature in self.method_map:
                yield self.method_map[callee_signature]

    def creates_intent(self):
        for callsite in self.callsites():
            callee_signature = callsite.get('vC')
            if re.match(r'Landroid/content/Intent;.<init>', callee_signature):
                return True
        return False

    def param_types(self):
        return [p.get('type') for p in self.element.findall('parameter')]

    def has_intent_param(self):
        return 'Landroid/content/Intent;' in self.param_types()

    def is_main(self):
        return self.element.get('name') == 'main'

world = visualize.StreamingInterface()
time.sleep(2)

# Find all Methods
classes = etree.parse('dump.xml').findall('class')
for cls in classes:
    classname = cls.get('name')
    methods = cls.findall('method');
    for method in methods:
        method = Method(classname, method)
        # Add Method to Graph
        gr.add_node(method)
        # Find Entry Points Into Program
        if method.is_main():
            main_methods.append(method)
        # Find all methods that create Intents
        if method.creates_intent():
            methods_create_intents.append(method)
        # Find all methods that take Intents as parameters
        if method.has_intent_param():
            methods_param_intents.append(method)    

# Create caller/callees relationships as directed edges
for method in Methods.values():
    for callee in method.callees():
        if not gr.has_edge((method, callee)):
            gr.add_edge((method, callee))

for main in main_methods:
    st, order = breadth_first_search(gr, root=main)
    gst = digraph()
    gst.add_spanning_tree(st)
    nodes = gst.nodes()
    for method in nodes:
        if method.creates_intent():
            world.send_entity_up(method.signature(), "square")
        else:
            world.send_entity_up(method.signature(), "circle")
    raw_input("Press Enter to Continue")
    world.clear()
#world.send_link_up(method.signature(), 0, callee.signature(), 0)
