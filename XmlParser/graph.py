from xml.etree.ElementTree import ElementTree
import re
import pydot
import collections

### Globals ###
INTENT_CLASS = 'Landroid/content/Intent;'
################

class Insn(object):
    """A Dalvik instruction."""

    def __init__(self, xml):
        self.xml = xml

    def __repr__(self):
        return str(self.index()) + ':' + self.opcode()

    def opcode(self):
        return self.xml.get('opCode')

    def index(self):
        return int(self.xml.get('index'), 16)

    def transfer(self, state):
        pass

    def is_branch(self):
        return False

    def is_conditional(self):
        return False

    def is_sink(self):
        return False

    def is_source(self):
        return False

    def target_index(self):
        return None

class Branch(Insn):
    def is_branch(self):
        return True

class Return(Branch):
    pass

class If(Branch):
    """Conditional jump comparing two operands.
    if-test vA, vB, +CCCC"""

    def target_index(self):
        return int(self.xml.get('vC'), 16)

    def is_conditional(self):
        return True

class IfZero(If):
    """Conditional jump comparing the operand with zero.
    if-testz vAA, +BBBB"""

    def target_index(self):
        return int(self.xml.get('vB'), 16)

class Goto(Branch):
    """Unconditional jump.
    goto +AA
    goto/16 +AAAA
    goto/32 +AAAAAAAA"""

    def target_index(self):
        return int(self.xml.get('vA'), 16)

class Move(Insn):
    """Register to register move"""

    def dest(self):
        return self.xml.get('vA')

    def src(self):
        return self.xml.get('vB')

    def transfer(self, state):
        state[self.dest()] = state[self.src()]

class MoveResultObject(Move):
    """Move the last result of an invoke-kind to register."""

    def transfer(self, state):
        state[self.dest()] = 1337

class Const(Move):
    """Move a constant value to register."""

    def transfer(self, state):
        state[self.dest()] = int(self.src(), 16)

class ConstString(Move):
    """Move a string reference to register."""

    def transfer(self, state):
        state[self.dest()] = self.src()

class Invoke(Insn):
    """A method invocation."""
    def __init__(self, xml):
        self.xml = xml
        pat = r'\w+(/\w+)*;'
        res = re.search(r'(?P<class>%s)\.(?P<method>[^\(]+)\(.*\)' % pat, self.signature())
        self.classname = res.group('class')
        self.methodname = res.group('method')

    def args(self):
        """List of register names"""
        argc = int(self.xml.get('vB'))-1 # destination register counts here (vD)
        return [self.xml.get(n) for n in ['vE', 'vF', 'vG'][:argc]]

    def dest(self):
        # Wierd -- can be either the calling object, or can be the reference
        # variable assigned to the result.
        return self.xml.get('vD')

    def signature(self):
        return self.xml.get('vC')

    def transfer(self, state):
        # Not sure what to here, see comment above in #dest
        state[self.dest()] = self.index()

    def is_source(self):
        return self.classname == INTENT_CLASS and self.methodname == '<init>'

    def is_sink(self):
        return self.methodname in ['sendBroadcast', 'sendOrderedBroadcast',
                'sendStickyBroadcast', 'startActivity', 'startService',
                'bindService']

classes = {
    'if-eq': If,
    'if-ne': If,
    'if-lt': If,
    'if-ge': If,
    'if-gt': If,
    'if-le': If,
    'if-eqz': IfZero,
    'if-nez': IfZero,
    'if-ltz': IfZero,
    'if-gez': IfZero,
    'if-gtz': IfZero,
    'if-lez': IfZero,
    'goto': Goto,
    'goto/16': Goto,
    'invoke-virtual': Invoke,
    'invoke-super': Invoke,
    'invoke-direct': Invoke,
    'invoke-static': Invoke,
    'invoke-interface': Invoke,
    'const/4': Const,
    'const/16': Const,
    'const': Const,
    'const-string': ConstString,
    'const-class': ConstString,
    'const-string/jumbo': ConstString,
    'const-class/jumbo': ConstString,
    'const/high16': Const,
    'const-wide/16': Const,
    'const-wide/32': Const,
    'const-wide': Const,
    'const-wide/high16': Const,
    'return': Return,
    'return-void': Return,
    'return-wide': Return,
    'return-object': Return,
    'move-result-object': MoveResultObject,
    'move': Move
}

class Graph(object):
    def __init__(self):
        self.adjacency_map = {}

    def add_node(self, node):
        self.adjacency_map[node] = []

    def add_edge(self, src, dest):
        self.adjacency_map[src].append(dest)

    def neighbors(self, node):
        for dest in self.adjacency_map[node]:
            yield dest

    def nodes(self):
        """Yields nodes in pre-order order, starting from root node."""
        visited = set()
        s = [self.root]
        while s:
            node = s.pop()
            yield node
            visited.add(node)
            for dest in self.neighbors(node):
                if dest not in visited:
                    s.append(dest)

    def search(self, src, dest):
        """Returns all paths without cycles from src to dest."""
        paths = []
        closed = set()
        def helper(current_node, path):
            closed.add(current_node)
            path += [current_node]
            if current_node == dest:
                paths.append(path)
            for node in self.neighbors(current_node):
                if node in closed:
                    continue
                helper(node, path)
            closed.remove(current_node)
        helper(src, [])
        return paths

    def filter_nodes(self, condition):
        for node in self.nodes():
            if condition(node):
                yield node

class ControlFlow(Graph):
    """Represents a Control Flow Graph. Each node is a basic block represented
    as a tuple of instructions having only one exit point and one entry point.
    An edge between two nodes implies that the exit of the first basic block
    jumps to the entry of the second."""

    def __init__(self, insns):
        """Build the control flow graph"""
        super(ControlFlow, self).__init__()

        def get_branch_targets():
            """Set of instructions which are branch targets."""
            insn_map = {}
            for insn in insns:
                insn_map[insn.index()] = insn
            branch_targets = set()
            for insn in insns:
                if insn.target_index():
                    insn = insn_map[insn.target_index()]
                    branch_targets.add(insn)
            return branch_targets

        def get_entry_points():
            """Set of instructions which are entry points. Entry point
            instructions include the first instruction, branch targets, or
            instructions that follow branches."""
            entry_points = get_branch_targets()
            for i, insn in enumerate(insns):
                if i == 0 or insns[i-1].is_branch():
                    entry_points.add(insn)
            return entry_points

        def get_basic_blocks():
            """List of basic blocks, where each basic block is a tuple of
            instructions with a single entry point and a single exit point."""
            entry_points = get_entry_points()
            basic_blocks = []
            basic_block = []
            for insn in insns:
                if insn in entry_points and basic_block:
                    basic_blocks.append(tuple(basic_block))
                    basic_block = []
                basic_block.append(insn)
            if basic_block:
                basic_blocks.append(tuple(basic_block))
            return basic_blocks

        nodes = get_basic_blocks()
        self.root = nodes[0]
        index_to_node = {}
        for node in nodes: self.add_node(node)
        for node in nodes: index_to_node[node[0].index()] = node
        for i, src in enumerate(nodes):
            exit_insn = src[-1]
            if not exit_insn.is_branch() or exit_insn.is_conditional():
                if (i+1) in range(len(nodes)):
                    dest = nodes[i+1]
                    self.add_edge(src, dest)
            if exit_insn.target_index():
                dest = index_to_node[exit_insn.target_index()]
                self.add_edge(src, dest)

    def visualize(self):
        def label(node):
            return '%d [%s]' % (node[0].index(), node[-1].opcode())
        graph = pydot.Dot(graph_type='digraph')
        for src in self.adjacency_map:
            for dest in self.neighbors(src):
                edge = pydot.Edge(label(src), label(dest))
                graph.add_edge(edge)
        graph.write_png('example.png')

class Method(object):
    def __init__(self, method_el):
        def parse_insns():
            bytecodes_el = method_el.find('code').find('bytecodes')
            if bytecodes_el is None:
                return []
            insns = []
            insn_els = bytecodes_el.findall('insn')
            for insn_el in insn_els:
                opcode = insn_el.get('opCode')
                insn = classes.setdefault(opcode, Insn)(insn_el)
                insns.append(insn)
            return insns

        self.xml = method_el
        self.name = method_el.get('name')
        self.cfg = ControlFlow(parse_insns())

    def initial_state(self):
        registers = {}
        params = self.params()
        num_registers = int(self.xml.find('code').get('registers'))
        i = num_registers - len(params)
        for param in params:
            name = 'v' + str(i)
            registers[name] = param
            i += 1
        return registers

    def find_paths(self, src, dest):
        return self.cfg.search(src, dest)

    def entry(self):
        return self.cfg.root

    def sinks(self):
        def has_sink(node):
            return [insn for insn in node if insn.is_sink()]
        return self.cfg.filter_nodes(has_sink)

    def sources(self):
        def has_source(node):
            return [insn for insn in node if insn.is_source()]
        if self.has_intent_param():
            yield self.cfg.root
        for source in self.cfg.filter_nodes(has_source):
            if source is not self.cfg.root:
                yield source

    def params(self):
        types = []
        parameter_els = self.xml.findall('parameter')
        for parameter_el in parameter_els:
            ptype = parameter_el.get('type')
            pname = parameter_el.get('name')
            types.append((ptype, pname))
        return types

    def has_intent_param(self):
        return INTENT_CLASS in [t for t, n in self.params()]

    def visualize(self):
        self.cfg.visualize()

def is_no_op(method_xml):
    return method_xml.find('code').find('bytecodes') is None

tree = ElementTree()
tree.parse('dump.xml')
for class_el in tree.findall('class'):
    for method_el in class_el.findall('method'):
        if is_no_op(method_el): continue
        method = Method(method_el)
        for source in method.sources():
            paths = method.find_paths(method.entry(), source)
            for path in paths:
                state = method.initial_state()
                for node in path:
                    for insn in node:
                        insn.transfer(state)
                        if insn.is_source():
                            print '-------------------'
                            print insn.signature(), '@', insn.xml.get('baseAddr')
                            print 'arguments: '
                            print [state[a] for a in insn.args()]
                            print '-------------------'

tree = ElementTree()
tree.parse('method.xml')
method = Method(tree.getroot())
method.visualize()
