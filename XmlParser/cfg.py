from xml.etree.ElementTree import ElementTree
import re
import collections

# Dalvik Instruction Set{{{
class Insn(object):
    '''
    A Dalvik instruction.
    '''
    def __init__(self, xml): self.xml = xml
    def opcode(self): return self.xml.get('opCode')
    def to_hex(self, attr): return int(self.xml.get(attr), 16)
    def index(self): return self.to_hex('index')
    def target_index(self): return None
    def is_branch(self): return self.target_index() is not None
    def __repr__(self): return '%d:%s' % (self.index(), self.opcode())
    def is_invoke(self): return False

class Invoke(Insn):
    def is_invoke(self): return True
    def parse_signature(self):
        signature = self.xml.get('vC')
        pat = r'\w+(/\w+)*;'
        res = re.search(r'(?P<class>%s)\.(?P<method>[^\(]+)\(.*\)' % pat, signature)
        return res

    def class_name(self):
        return self.parse_signature().group('class')

    def method_name(self):
        return self.parse_signature().group('method')

class If(Insn):
    '''
    A conditional jump comparing two operands.
    if-test vA, vB, +CCCC
    '''
    def target_index(self): return self.to_hex('vC')
    def conditional(self): return True

class IfZero(If):
    '''
    A conditional jump comparing the operand with zero.
    if-testz vAA, +BBBB
    '''
    def target_index(self): return self.to_hex('vB')

class Goto(Insn):
    '''
    An unconditional jump.
    goto +AA
    goto/16 +AAAA
    goto/32 +AAAAAAAA
    '''
    def target_index(self): return self.to_hex('vA')
    def conditional(self): return False
#}}}

def get_instructions(method_el):
    '''
    Returns a list of instructions from an XML element with <method> tag.
    '''
    classes = {
        'if-eq': If,
        'if-ne': If,
        'if-lt': If,
        'if-ge': If,
        'if-gt': If,
        'if-le': If,
        'if-eqz': IfZero,
        'if-nez': IfZero,
        'if-ltz': IfZero,
        'if-gez': IfZero,
        'if-gtz': IfZero,
        'if-lez': IfZero,
        'goto': Goto,
        'invoke-virtual': Invoke,
        'invoke-super': Invoke,
        'invoke-direct': Invoke,
        'invoke-static': Invoke,
        'invoke-interface': Invoke
    }
    bytecodes_el = method_el.find('code').find('bytecodes')
    if bytecodes_el is None:
        return []
    insns = []
    insn_els = bytecodes_el.findall('insn')
    for insn_el in insn_els:
        opcode = insn_el.get('opCode')
        insn = classes.setdefault(opcode, Insn)(insn_el)
        insns.append(insn)
    return insns

def mapped_instructions(insns):
    '''
    Given an ordered list of instructions, return a dictionary mapping
    instruction indices to instructions.
    '''
    result = {}
    for insn in insns:
        result[insn.index()] = insn
    return result

def branch_targets(insns):
    '''
    Given an oredered list of instructions, return a Set of instructions which
    are branch targets.
    '''
    result = set()
    insn_map = mapped_instructions(insns)
    for insn in insns:
        if insn.is_branch():
            insn = insn_map[insn.target_index()]
            result.add(insn)
    return result

def entry_points(insns):
    '''
    Given an ordered list of instructions, return a Set of instructions which
    are entry points. Entry point instructions include the first instruction,
    branch targets, or instructions that follow branches.
    '''
    result = branch_targets(insns)
    for i, insn in enumerate(insns):
        if not i:
            result.add(insn)
        elif insn.is_branch() and (i+1) < len(insns):
            result.add(insns[i+1])
    return result

def basic_blocks(insns):
    '''
    Given an ordered list of instructions, return a list of basic blocks, where
    each basic block is a tuple of instructions with a single entry point and a
    single exit point.
    '''
    basic_blocks = []
    basic_block = []
    ep = entry_points(insns)
    for insn in insns:
        if insn in ep and basic_block:
            basic_blocks.append(tuple(basic_block))
            basic_block = []
        basic_block.append(insn)
    if basic_block:
        basic_blocks.append(tuple(basic_block))
    return basic_blocks

class CFG(object):
    '''
    Represents a Control Flow Graph. Each node is a basic block represented as
    a tuple of instructions having only one exit point and one entry point. An
    edge between two nodes implies that the exit of the first basic block jumps
    to the entry of the second.
    '''
    def __init__(self, basic_blocks):
        self.nodes = collections.defaultdict(list)
        self.entry_indices = {}
        for basic_block in basic_blocks:
            entry_index = basic_block[0].index()
            self.entry_indices[entry_index] = basic_block
        for i, basic_block in enumerate(basic_blocks):
            exit_insn = basic_block[-1]
            if not exit_insn.is_branch() or exit_insn.conditional():
                if (i+1) in range(len(basic_blocks)):
                    next_basic_block = basic_blocks[i+1]
                    self.add_edge(basic_block, next_basic_block)
            if exit_insn.is_branch():
                target_block = self.entry_indices[exit_insn.target_index()]
                self.add_edge(basic_block, target_block)

    def add_edge(self, src, dest):
        self.nodes[src].append(dest)

    def traverse(self, visit):
        root = self.entry_indices[0]
        s = [root]
        visited = set()
        while s:
            node = s.pop()
            visit(node)
            visited.add(node)
            for dest in self.nodes[node]:
                if dest not in visited:
                    s.append(dest)

tree = ElementTree()
tree.parse('method.xml')
cfg = CFG(basic_blocks(get_instructions(tree)))

invokes = []
def get_invokes(basic_block):
    for insn in basic_block:
        if insn.is_invoke():
            invokes.append((insn.class_name(), insn.method_name()))
cfg.traverse(get_invokes)

for invoke in invokes:
    class_name, method_name = invoke
    if class_name == 'Landroid/content/Intent;' and method_name == '<init>':
        print invoke
