from xml.etree.ElementTree import ElementTree
import re
import pydot

INTENT_CLASS = 'Landroid/content/Intent;'

# Dalvik Instruction Set{{{
class Insn(object):
    """A Dalvik instruction."""
    def __init__(self, xml): self.xml = xml
    def __repr__(self): return '%d:%s' % (self.index(), self.opcode())
    def opcode(self): return self.xml.get('opCode')
    def to_hex(self, attr): return int(self.xml.get(attr), 16)
    def index(self): return self.to_hex('index')
    def target_index(self): return None
    def is_branch(self): return self.target_index() is not None
    def is_invoke(self): return False
    def is_intent_source(self): return False

class Invoke(Insn):
    def is_invoke(self): return True
    def is_intent_source(self):
        return self.class_name() == INTENT_CLASS and self.method_name() == '<init>'
    def parse_signature(self):
        signature = self.xml.get('vC')
        pat = r'\w+(/\w+)*;'
        res = re.search(r'(?P<class>%s)\.(?P<method>[^\(]+)\(.*\)' % pat, signature)
        return res

    def class_name(self):
        return self.parse_signature().group('class')

    def method_name(self):
        return self.parse_signature().group('method')

class If(Insn):
    """Conditional jump comparing two operands.
    if-test vA, vB, +CCCC"""
    def target_index(self): return self.to_hex('vC')
    def conditional(self): return True

class IfZero(If):
    """Conditional jump comparing the operand with zero.
    if-testz vAA, +BBBB"""
    def target_index(self): return self.to_hex('vB')

class Goto(Insn):
    """Unconditional jump.
    goto +AA
    goto/16 +AAAA
    goto/32 +AAAAAAAA"""
    def target_index(self): return self.to_hex('vA')
    def conditional(self): return False
#}}}

classes = {
    'if-eq': If,
    'if-ne': If,
    'if-lt': If,
    'if-ge': If,
    'if-gt': If,
    'if-le': If,
    'if-eqz': IfZero,
    'if-nez': IfZero,
    'if-ltz': IfZero,
    'if-gez': IfZero,
    'if-gtz': IfZero,
    'if-lez': IfZero,
    'goto': Goto,
    'invoke-virtual': Invoke,
    'invoke-super': Invoke,
    'invoke-direct': Invoke,
    'invoke-static': Invoke,
    'invoke-interface': Invoke
}

class CFG(object):
    """Represents a Control Flow Graph. Each node is a basic block represented
    as a tuple of instructions having only one exit point and one entry point.
    An edge between two nodes implies that the exit of the first basic block
    jumps to the entry of the second."""
    def __init__(self, insns):
        def branch_targets():
            """Set of instructions which are branch targets."""
            insn_map = {}
            for insn in insns: insn_map[insn.index()] = insn

            result = set()
            for insn in insns:
                if insn.is_branch():
                    insn = insn_map[insn.target_index()]
                    result.add(insn)
            return result

        def entry_points():
            """Set of instructions which are entry points. Entry point
            instructions include the first instruction, branch targets, or
            instructions that follow branches."""
            result = branch_targets()
            for i, insn in enumerate(insns):
                if not i:
                    result.add(insn)
                elif insn.is_branch() and (i+1) in range(len(insns)):
                    result.add(insns[i+1])
            return result

        def get_basic_blocks():
            """List of basic blocks, where each basic block is a tuple of
            instructions with a single entry point and a single exit point."""
            basic_blocks = []
            basic_block = []
            ep = entry_points()
            for insn in insns:
                if insn in ep and basic_block:
                    basic_blocks.append(tuple(basic_block))
                    basic_block = []
                basic_block.append(insn)
            if basic_block:
                basic_blocks.append(tuple(basic_block))
            return basic_blocks

        self.adjacency_map = {} # {node: [dest1, dest2]}
        self.entry_points = {} # {entry index: node}

        nodes = get_basic_blocks()
        for node in nodes:
            self.entry_points[node[0].index()] = node
            self.adjacency_map[node] = []
        for i, src in enumerate(nodes):
            exit_insn = src[-1]
            if not exit_insn.is_branch() or exit_insn.conditional():
                if (i+1) in range(len(nodes)):
                    dest = nodes[i+1]
                    self.add_edge(src, dest)
            if exit_insn.is_branch():
                dest = self.entry_points[exit_insn.target_index()]
                self.add_edge(src, dest)
        self.nodes = nodes

    def get_root(self):
        return self.entry_points[0]

    def add_edge(self, src, dest):
        self.adjacency_map[src].append(dest)

    def traverse(self, visit, start=None):
        """Traverse the control flow graph starting from root node with a given
        callback function."""
        s = [start if start else self.get_root()]
        visited = set()
        while s:
            node = s.pop()
            visit(node)
            visited.add(node)
            for dest in self.adjacency_map[node]:
                if dest not in visited:
                    s.append(dest)

    def basic_blocks(self):
        """A list of basic blocks"""
        return self.nodes

    def visualize(self):
        graph = pydot.Dot(graph_type='digraph')
        for src in self.adjacency_map:
            for dest in self.adjacency_map[src]:
                edge = pydot.Edge(str(src[0]), str(dest[0]))
                graph.add_edge(edge)
        graph.write_png('example.png')

class Method(object):
    def __init__(self, method_el):
        def parse_insns():
            bytecodes_el = method_el.find('code').find('bytecodes')
            if bytecodes_el is None:
                return []
            insns = []
            insn_els = bytecodes_el.findall('insn')
            for insn_el in insn_els:
                opcode = insn_el.get('opCode')
                insn = classes.setdefault(opcode, Insn)(insn_el)
                insns.append(insn)
            return insns
        self.xml = method_el
        self.cfg = CFG(parse_insns())

    def param_types(self):
        types = []
        parameter_els = self.xml.findall('parameter')
        for parameter_el in parameter_els:
            types.append(parameter_el.get('type'))
        return types

    def has_intent_param(self):
        return INTENT_CLASS in self.param_types()

    def sources(self):
        """List of Intent sources"""
        sources = set()
        basic_blocks = self.cfg.basic_blocks()
        if self.has_intent_param():
            sources.append(basic_blocks[0])
        for basic_block in basic_blocks:
            for insn in basic_block:
                if insn.is_intent_source():
                    sources.add(basic_block)
        return list(sources)

    def visualize(self):
        self.cfg.visualize()

tree = ElementTree()
tree.parse('method.xml')
method = Method(tree)
method.visualize()
