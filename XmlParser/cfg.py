from xml.etree.ElementTree import ElementTree
import re
import pydot

INTENT_CLASS = 'Landroid/content/Intent;'

# Dalvik Instruction Set{{{
class Insn(object):
    """A Dalvik instruction."""

    def __init__(self, xml):
        self.xml = xml

    def __repr__(self):
        return str(self.index()) + ':' + self.opcode()

    def opcode(self):
        return self.xml.get('opCode')
    
    def index(self):
        return int(self.xml.get('index'), 16)

    def is_branch(self):return False
    def is_conditional(self): return False
    def is_sink(self): return False
    def is_source(self): return False
    def target_index(self): return None
    def transfer(self, state): pass
    def dest(self): return None
    def src(self): return None

class Branch(Insn):
    def is_branch(self):
        return True

    def is_conditional(self):
        return True

class If(Branch):
    """Conditional jump comparing two operands.
    if-test vA, vB, +CCCC"""

    def target_index(self):
        return int(self.xml.get('vC'), 16)

class IfZero(Branch):
    """Conditional jump comparing the operand with zero.
    if-testz vAA, +BBBB"""

    def target_index(self):
        return int(self.xml.get('vB'), 16)

class Goto(Branch):
    """Unconditional jump.
    goto +AA
    goto/16 +AAAA
    goto/32 +AAAAAAAA"""

    def target_index(self):
        return int(self.xml.get('vA'), 16)

    def is_conditional(self):
        return False

class Return(Branch):
    def is_conditional(self):
        return False

class Move(Insn):
    """Register to register move"""

    def dest(self):
        return self.xml.get('vA')

    def src(self):
        return self.xml.get('vB')

    def transfer(self, state):
        state[self.dest()] = state[self.src()]

class MoveResultObject(Move):
    """Move the last result of an invoke-kind to register."""

    def transfer(self, state):
        state[self.dest()] = state['invoke-result']

class Const(Move):
    """Move a constant value to register."""

    def transfer(self, state):
        state[self.dest()] = int(self.src(), 16)

class ConstString(Move):
    """Move a string reference to register."""

    def transfer(self, state):
        state[self.dest()] = self.src()

class Invoke(Insn):
    """A method invocation."""
    def __init__(self, xml):
        self.xml = xml
        sig = xml.get('vC')
        pat = r'\w+(/\w+)*;'
        res = re.search(r'(?P<class>%s)\.(?P<method>[^\(]+)\(.*\)' % pat, sig)
        self.classname = res.group('class')
        self.methodname = res.group('method')

    def transfer(self, state):
        state['invoke-result'] = self.index()

    def is_source(self):
        return self.classname == INTENT_CLASS and self.methodname == '<init>'

    def is_sink(self):
        return self.methodname in ['sendBroadcast', 'sendOrderedBroadcast',
                'sendStickyBroadcast', 'startActivity', 'startService',
                'bindService']

#}}}

classes = {
    'if-eq': If,
    'if-ne': If,
    'if-lt': If,
    'if-ge': If,
    'if-gt': If,
    'if-le': If,
    'if-eqz': IfZero,
    'if-nez': IfZero,
    'if-ltz': IfZero,
    'if-gez': IfZero,
    'if-gtz': IfZero,
    'if-lez': IfZero,
    'goto': Goto,
    'invoke-virtual': Invoke,
    'invoke-super': Invoke,
    'invoke-direct': Invoke,
    'invoke-static': Invoke,
    'invoke-interface': Invoke,
    'const/4': Const,
    'const/16': Const,
    'const': Const,
    'const-string': ConstString,
    'const-string/jumbo': ConstString,
    'const-class/jumbo': ConstString,
    'const/high16': Const,
    'const-wide/16': Const,
    'const-wide/32': Const,
    'const-wide': Const,
    'const-wide/high16': Const,
    'return-void': Return,
    'return-wide': Return,
    'return-object': Return
}

class CFG(object):
    """Represents a Control Flow Graph. Each node is a basic block represented
    as a tuple of instructions having only one exit point and one entry point.
    An edge between two nodes implies that the exit of the first basic block
    jumps to the entry of the second."""

    def __init__(self, insns):
        def branch_targets():
            """Set of instructions which are branch targets."""
            insn_map = {}
            for insn in insns:
                insn_map[insn.index()] = insn
            result = set()
            for insn in insns:
                if insn.target_index():
                    insn = insn_map[insn.target_index()]
                    result.add(insn)
            return result

        def entry_points():
            """Set of instructions which are entry points. Entry point
            instructions include the first instruction, branch targets, or
            instructions that follow branches."""
            result = branch_targets()
            for i, insn in enumerate(insns):
                if not i:
                    result.add(insn)
                elif insn.is_branch() and (i+1) in range(len(insns)):
                    result.add(insns[i+1])
            return result

        def get_basic_blocks():
            """List of basic blocks, where each basic block is a tuple of
            instructions with a single entry point and a single exit point."""
            basic_blocks = []
            basic_block = []
            ep = entry_points()
            for insn in insns:
                if insn in ep and basic_block:
                    basic_blocks.append(tuple(basic_block))
                    basic_block = []
                basic_block.append(insn)
            if basic_block:
                basic_blocks.append(tuple(basic_block))
            return basic_blocks

        self.adjacency_map = {} # {node: [dest1, dest2]}
        self.entry_points = {} # {entry index: node}
        self.nodes = get_basic_blocks()
        for node in self.nodes:
            self.entry_points[node[0].index()] = node
            self.adjacency_map[node] = []
        for i, src in enumerate(self.nodes):
            exit_insn = src[-1]
            if not exit_insn.is_branch() or exit_insn.is_conditional():
                if (i+1) in range(len(self.nodes)):
                    dest = self.nodes[i+1]
                    self.add_edge(src, dest)
            if exit_insn.target_index():
                dest = self.entry_points[exit_insn.target_index()]
                self.add_edge(src, dest)

    def get_root(self):
        return self.entry_points[0]

    def add_edge(self, src, dest):
        self.adjacency_map[src].append(dest)

    def find_paths(self, src, dest):
        """Finds all paths from source to dest"""
        paths = [[]]
        def update_paths(node):
            paths[-1].append(node)
            if node == dest:
                paths.append([])
        self.traverse(update_paths)
        return [p for p in paths if p]

    def traverse(self, visit, start=None):
        """Traverse the control flow graph starting from root node with a given
        callback function, in preorder depth first order."""
        s = [start if start else self.get_root()]
        visited = set()
        while s:
            node = s.pop()
            visit(node)
            visited.add(node)
            for dest in self.adjacency_map[node]:
                if dest not in visited:
                    s.append(dest)

    def filter_nodes(self, condition):
        found = []
        def add_if_true(node):
            if condition(node): found.append(node)
        self.traverse(add_if_true)
        return found

    def visualize(self):
        graph = pydot.Dot(graph_type='digraph')
        for src in self.adjacency_map:
            for dest in self.adjacency_map[src]:
                edge = pydot.Edge(str(src[0]), str(dest[0]))
                graph.add_edge(edge)
        graph.write_png('example.png')

class Method(object):
    def __init__(self, method_el):
        def parse_insns():
            bytecodes_el = method_el.find('code').find('bytecodes')
            if bytecodes_el is None:
                return []
            insns = []
            insn_els = bytecodes_el.findall('insn')
            for insn_el in insn_els:
                opcode = insn_el.get('opCode')
                insn = classes.setdefault(opcode, Insn)(insn_el)
                insns.append(insn)
            return insns

        self.xml = method_el
        self.name = method_el.get('name')
        self.cfg = CFG(parse_insns())

    def initial_state(self):
        registers = {}
        params = self.params()
        num_registers = int(self.xml.find('code').get('registers'))
        i = num_registers - len(params)
        for param in params:
            name = 'v' + str(i)
            registers[name] = param
            i += 1
        return registers

    def sinks(self):
        def has_sink(node):
            return [insn for insn in node if insn.is_sink()]
        return self.cfg.filter_nodes(has_sink)

    def sources(self):
        def has_source(node):
            return [insn for insn in node if insn.is_source()]
        result = self.cfg.filter_nodes(has_source)
        root = self.cfg.get_root()
        if self.has_intent_param() and root not in result:
            result.append(root)
        return result

    def params(self):
        types = []
        parameter_els = self.xml.findall('parameter')
        for parameter_el in parameter_els:
            ptype = parameter_el.get('type')
            pname = parameter_el.get('name')
            types.append((ptype, pname))
        return types

    def has_intent_param(self):
        return INTENT_CLASS in [t for t, n in self.params()]

    def visualize(self):
        self.cfg.visualize()

def is_no_op(method_xml):
    return method_xml.find('code').find('bytecodes') is None

tree = ElementTree()
tree.parse('dump.xml')
for class_el in tree.findall('class'):
    for method_el in class_el.findall('method'):
        if is_no_op(method_el): continue
        method = Method(method_el)
        for source in method.sources():
            for sink in method.sinks():
                paths = method.cfg.find_paths(source, sink)
                for path in paths:
                    state = method.initial_state()
                    for node in path:
                        for insn in node:
                            insn.transfer(state)
                    print state
